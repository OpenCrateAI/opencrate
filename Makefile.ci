SHELL := /bin/bash
PYTHON_VERSION ?= 3.10
RUNTIME ?= cuda
VERSION ?= $(shell cat VERSION | tr -d '\n')
CACHE_IMAGE_PREFIX ?= braindotai/opencrate-build-cache

# Defaults
REBUILD_FLAG ?= false
CACHE_UPDATE ?= false

.SILENT:
.ONESHELL:

# Color and format codes
BOLD := \033[1m
RESET := \033[0m
GREEN := \033[32m
YELLOW := \033[33m
BOLD_RED := \033[1;31m
BOLD_GREEN := \033[1;32m
BOLD_YELLOW := \033[1;33m
BOLD_BLUE := \033[1;34m
BOLD_ORANGE := \033[1;38;5;214m

# This target builds and tests a single Docker image for CI/CD workflows.
build:
	CACHE_IMAGE_VAR="$(CACHE_IMAGE_PREFIX):$(RUNTIME)-py$(PYTHON_VERSION)";

# 1. Base Image Pull Logic
	PULL_FLAG="";
	if [ "$(REBUILD_FLAG)" = "true" ]; then
		echo -e "  $(BOLD_ORANGE)! FORCE PULL: Updating base images !$(RESET)";
		PULL_FLAG="--pull";
	fi;

# 2. REGISTRY Cache Logic (Remote)
# We always try to pull from remote registry to warm the cache
	CACHE_ARGS="--cache-from type=registry,ref=$$CACHE_IMAGE_VAR,ignore-error=true";

	if [ "$(MODE)" = "push" ] && { [ "$(CACHE_UPDATE)" = "true" ] || [ "$(REBUILD_FLAG)" = "true" ]; }; then
		# Only push to remote registry if we are actually releasing and have changes
		CACHE_ARGS="$$CACHE_ARGS --cache-to type=registry,ref=$$CACHE_IMAGE_VAR,mode=max";
	fi;

# 3. LOCAL Cache Logic (The Bridge between Test -> Push)
# If LOCAL_CACHE_PATH is set (e.g., by GitHub Actions), we use it to share state between steps
	if [ -n "$(LOCAL_CACHE_PATH)" ]; then
		echo -e "  $(BOLD_BLUE)⚡ Local Cache Enabled at: $(LOCAL_CACHE_PATH)$(RESET)";
		# Always read from local cache
		CACHE_ARGS="$$CACHE_ARGS --cache-from type=local,src=$(LOCAL_CACHE_PATH)";
		# Always write to local cache (so Step 1 populates it for Step 2)
		# mode=max ensures we cache the intermediate pip install layers
		CACHE_ARGS="$$CACHE_ARGS --cache-to type=local,dest=$(LOCAL_CACHE_PATH),mode=max";
	fi;

# 4. Mode Specifics
	PLATFORM_FLAG="";
	OUTPUT_ARGS="";
	if [ "$(MODE)" = "test" ]; then
		echo -e "$(BOLD_YELLOW)\n======== ● Building local (Test): $(RUNTIME)-py$(PYTHON_VERSION) ========$(RESET)\n";
		PLATFORM_FLAG="--platform linux/amd64";
		OUTPUT_ARGS="--load";
	elif [ "$(MODE)" = "push" ]; then
		echo -e "$(BOLD_YELLOW)\n======== ● Building & Pushing (Release): $(RUNTIME)-py$(PYTHON_VERSION) ========$(RESET)\n";
		PLATFORM_FLAG="--platform linux/amd64,linux/arm64";
		OUTPUT_ARGS="--push";
	else
		echo -e "$(BOLD_RED)\n!!!!!!!! ✗ ERROR: Invalid MODE !!!!!!!!$(RESET)\n";
		exit 1;
	fi;

# 5. Execution
	IMAGE_TAG="braindotai/opencrate-$(RUNTIME)-py$(PYTHON_VERSION):$(VERSION)";
	DOCKERFILE_PATH="./docker/dockerfiles/Dockerfile.$(RUNTIME)-py$(PYTHON_VERSION)";
	
	if docker buildx build \
		$$PLATFORM_FLAG \
		-f "$$DOCKERFILE_PATH" \
		-t "$$IMAGE_TAG" \
		$$OUTPUT_ARGS \
		$$PULL_FLAG \
		$$CACHE_ARGS \
		.; then
		echo -e "\n$(BOLD_GREEN)======== ✓ Success: $(RUNTIME)-py$(PYTHON_VERSION) ========$(RESET)\n";
	else
		echo -e "\n$(BOLD_RED)!!!!!!!! ✗ FAILED: $(RUNTIME)-py$(PYTHON_VERSION) !!!!!!!!$(RESET)\n";
		exit 1;
	fi


# This target pushes the images as the latest tag to the registry.
release:
	@echo -e "$(BOLD_YELLOW)\n======== ● Tagging 'latest' for all images with version $(VERSION) ========$(RESET)\n"
	@set -e; \
	PYTHON_VERSIONS="3.7 3.8 3.9 3.10 3.11 3.12"; \
	for python_version in $$PYTHON_VERSIONS; do \
		for runtime in cpu cuda; do \
			IMAGE_TAG="braindotai/opencrate-$$runtime-py$$python_version:$(VERSION)"; \
			LATEST_TAG="braindotai/opencrate-$$runtime-py$$python_version:latest"; \
			echo -e "  $(BOLD_BLUE)▶ Tagging $$IMAGE_TAG as $$LATEST_TAG$(RESET)"; \
			docker buildx imagetools create -t "$$LATEST_TAG" "$$IMAGE_TAG"; \
		done; \
	done; \
	echo -e "\n$(BOLD_GREEN)======== ✓ All images tagged as latest ========$(RESET)\n";