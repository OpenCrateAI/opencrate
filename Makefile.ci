SHELL := /bin/bash
PYTHON_VERSION ?= 3.10
RUNTIME ?= cuda
VERSION ?= $(shell cat VERSION | tr -d '\n')
CACHE_IMAGE_PREFIX ?= braindotai/opencrate-build-cache

# Read versions from shared file
PYTHON_VERSIONS_LIST := $(shell cat PYTHON_VERSIONS | tr '\n' ' ')

# Defaults
REBUILD_FLAG ?= false
CACHE_UPDATE ?= false

.SILENT:
.ONESHELL:

# Color and format codes
BOLD := \033[1m
RESET := \033[0m
GREEN := \033[32m
YELLOW := \033[33m
BOLD_RED := \033[1;31m
BOLD_GREEN := \033[1;32m
BOLD_YELLOW := \033[1;33m
BOLD_BLUE := \033[1;34m
BOLD_ORANGE := \033[1;38;5;214m

# This target builds and tests a single Docker image for CI/CD workflows.
build:
	CACHE_IMAGE_VAR="$(CACHE_IMAGE_PREFIX):$(RUNTIME)-py$(PYTHON_VERSION)";

# 1. Base Image Pull Logic
	PULL_FLAG="";
	if [ "$(REBUILD_FLAG)" = "true" ]; then
		echo -e "  $(BOLD_ORANGE)! FORCE PULL: Updating base images !$(RESET)";
		PULL_FLAG="--pull";
	fi;

# 2. REGISTRY Cache Logic (Remote)
# Always read from remote cache to warm the internal builder
	CACHE_ARGS="--cache-from type=registry,ref=$$CACHE_IMAGE_VAR,ignore-error=true";

# Only push to remote registry if we are PUSHING and (deps changed or forced)
	if [ "$(MODE)" = "push" ] && { [ "$(CACHE_UPDATE)" = "true" ] || [ "$(REBUILD_FLAG)" = "true" ]; }; then
		echo -e "  $(BOLD_ORANGE)! CACHE WRITE: Uploading new build layers to $$CACHE_IMAGE_VAR !$(RESET)";
		CACHE_ARGS="$$CACHE_ARGS --cache-to type=registry,ref=$$CACHE_IMAGE_VAR,mode=max";
	else
		echo -e "  $(GREEN)✓ CACHE READ-ONLY: Skipping cache upload $(RESET)";
	fi;

# 3. Mode Specifics
	PLATFORM_FLAG="";
	OUTPUT_ARGS="";
	if [ "$(MODE)" = "test" ]; then
		echo -e "$(BOLD_YELLOW)\n======== ● Building local (Test): $(RUNTIME)-py$(PYTHON_VERSION) ========$(RESET)\n";
		PLATFORM_FLAG="--platform linux/amd64";
		OUTPUT_ARGS="--load";
	elif [ "$(MODE)" = "push" ]; then
		echo -e "$(BOLD_YELLOW)\n======== ● Building & Pushing (Release): $(RUNTIME)-py$(PYTHON_VERSION) ========$(RESET)\n";
		PLATFORM_FLAG="--platform linux/amd64,linux/arm64";
		OUTPUT_ARGS="--push";
	else
		echo -e "$(BOLD_RED)\n!!!!!!!! ✗ ERROR: Invalid MODE !!!!!!!!$(RESET)\n";
		exit 1;
	fi;

# 4. Execution
	IMAGE_TAG="braindotai/opencrate-$(RUNTIME)-py$(PYTHON_VERSION):$(VERSION)";
	DOCKERFILE_PATH="./docker/dockerfiles/Dockerfile.$(RUNTIME)-py$(PYTHON_VERSION)";
	
	if docker buildx build \
		$$PLATFORM_FLAG \
		-f "$$DOCKERFILE_PATH" \
		-t "$$IMAGE_TAG" \
		$$OUTPUT_ARGS \
		$$PULL_FLAG \
		$$CACHE_ARGS \
		.; then
		echo -e "\n$(BOLD_GREEN)======== ✓ Success: $(RUNTIME)-py$(PYTHON_VERSION) ========$(RESET)\n";
	else
		echo -e "\n$(BOLD_RED)!!!!!!!! ✗ FAILED: $(RUNTIME)-py$(PYTHON_VERSION) !!!!!!!!$(RESET)\n";
		exit 1;
	fi


# This target pushes the images as the latest tag to the registry.
release:
	@echo -e "$(BOLD_YELLOW)\n======== ● Tagging 'latest' for all images with version $(VERSION) ========$(RESET)\n"
	@set -e; \
	for python_version in $(PYTHON_VERSIONS_LIST); do \
		for runtime in cpu cuda; do \
			IMAGE_TAG="braindotai/opencrate-$$runtime-py$$python_version:$(VERSION)"; \
			LATEST_TAG="braindotai/opencrate-$$runtime-py$$python_version:latest"; \
			echo -e "  $(BOLD_BLUE)▶ Tagging $$IMAGE_TAG as $$LATEST_TAG$(RESET)"; \
			docker buildx imagetools create -t "$$LATEST_TAG" "$$IMAGE_TAG"; \
		done; \
	done; \
	echo -e "\n$(BOLD_GREEN)======== ✓ All images tagged as latest ========$(RESET)\n";